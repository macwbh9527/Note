## 1、 Java语言有哪些特点

- 简单易学（Java语言的语法与C语言和C++语言很接近） 

- 面向对象（封装，继承，多态） 

- 平台无关性（Java虚拟机实现平台无关性） 

- 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）

-  支持多线程（多线程机制使应用程序在同一时间并行执行多项任） 

- 健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等） 

- 安全性好

  ---

  

## 2.、JDK,JRE,JVM之间的区别**

- **JDK**(Java SE Development Kit), **Java开发工具包**，它提供了**编译**、**运行**Java程序所需的各种工具和资源，包括**Java编译器**、**Java运行时环境**，以及常用的**Java类库**等

- **JRE**(Java Runtime Environment), **Java运行环境**，用于**运行**Java的字节码文件。JRE中包括了JVM以及JVM工作所需要的类库，普通用户而只需要安装JRE来运行Java程序，而程序开发者必须安装JDK来编译、调试程序。

  > Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java
  > Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包

- **JVM**(ava Virtual Mechinal), **Java虚拟机**，是JRE的一部分，它是整个java实现跨平台的最核心的部分，负责运行字节码文件。

- 

我们写Jva代码，用txt就可以写，但是写出来的)ava代码，想要运行，需要先编译成**字节码**，那就需要编译器，而JDK中就包含了编译器javac. 编译之后的字节码，想要运行，就需要一个可以执行字节码的程序，这个程序就是JVM(Java虚拟机），专门用来执行Java字节码的。

如果我们要开发Java程序，那就需要JDK, 因为要编译Java源文件。
如果我们只想运行已经编译好的Java字节码文件，也就是*.class文件，那么就只需要JRE。
JDK中包含了JRE,JRE中包含了JVM。

![img](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302110929144.png)

![img](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302110931834.png)

另外，JVM在执行Java字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令是有可能不一样的，所以就导致不同操作系统上的JVM是不一样的，所以我们在安装JDK时需要选择操作系统。
另外，JVM是用来执行Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运行，比如Apache Groovy,Scala and Kotlin等等。

---

## 3.、什么是字节码？采用字节码的好处是什么？

编译器(javac)将Java源文件(*.java)文件编译成为字节码文件(.class),可以做到一次编译多处运行，windows.上编译好的class文件，可以直接在linux.上运行，通过这种方式做到跨平台，不过java的跨平台有一个前提条件，就是不同的操作系统上安装的JDK或JRE是不一样的，虽然字节码是通用的，但是需要把字节码解释成各个操作系统的机器码是需要不同的解释器的，所以针对各个操作系统需要有各自的JDK或JRE

==**跨平台，可移植**==

采用字节码的好处，一方面实现了跨平台，另外一方面也提高了代码执行的性能，编译器在编译源代码时可以做⼀些编译期的优化，比如锁消除、标量替换、方法内联等。

---

## 4 、Java有哪些数据类型

- 分类
  - 基本数据类型 
    - 数值型 
    - 整数类型(byte,short,int,long) 
      - 浮点类型(float,double)
      -  字符型(char) 
      - 布尔型(boolean) 
  - 引用数据类型 
    - 类(class) 
      - 接口(interface) 
      - 数组([])

![img](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302110948535.jpeg)

---

## 5、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上

​	1、byte、char、short、int四种基本类型以及它们的包装类（需要Java5.0/1.5以上版本支持）**都可以**用于switch语句。

​	2、long、float、double、[boolean四种基本类型以及它们的包装类（在Java所有版本中）都**不能**用于switch语句。

​	3、enum类型，即枚举类型可以用于switch语句，但是要在Java5.0（1.5）版本以上才支持。

​	4、所有类型的对象（包括String类，但在Java5.0/1.5以上版本中，该项要排除byte、char、short、int四种基本类型对应的包装类）都不能用于switch语句。

----

## 6、用最有效率的方法计算 2 乘以 8

2 << 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）

```java
int a = 2;
a = a<<3
// 输出2*8=16
```

---

## 7、Java中取整的情况

**1.向下取整**

​	**Math.floor()**，向下取整就是取最小的整数，如1.9就返回值为1.0，-1.9就返回-2.0，返回的总是小于等于原数。

**2.向上取整**

​	**Math.ceil()**，向上取整顾名思义就是取最大的整数，如1.9就返回2.0，-1.9就返回-1.0，返回的总是大于等于原数

**3.接近取整**

​	**Math.rint()**，接近取整顾名思义就是接近哪个取整哪个，如1.6接近2，所以就取2；1.4接近1，所以就取1；那么1.5呢，1.5跟1和2都很接近，这时候就取偶数

**4.四舍五入或（+0.5向下取整）**

​	**Math.round**(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数 上加 0.5 然后进行下取整。

---

## 8、float f=3.4;是否正确

不正确。

3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（downcasting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。

---

## 9、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗

- 对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换 类型才能赋值给 short 型。 

- 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强 制类型转换。

  

### Java中 = 和 += 的区别

1）+：在编译器将右边的表达式结果计算出来后，和左边的变量类型比较精度，如果左边的变量精度低于右边的结果的精度，编译器会显式的报错，告诉程序员去强制转型。（所以s1 = s1 + 1出错）最后将表达式的结果复制到变量所在的内存区。

2）+=：编译器自动隐式直接将+=运算符后面的操作数强制装换为前面变量的类型，然后在变量所在的内存区上直接根据右边的操作数修改左边变量内存存储的二进制数值（所以 s += 1不报错）最后达到和赋值运算符相同的目的。与前者相比，由于后者是位操作，效率也较前者高。

---

## 10、访问修饰符

- 定义
  - Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种 不同的访问权限。

- 分类
  - private : 在**同一类内**可见。使用对象：变量、方法。 注意：不能修饰类（外部类）
  -  default (即缺省，什么也不写，不使用任何关键字）: 在**同一包内**可见，不使用任何修饰符。 使用对象：类、接口、变量、方法。 
  - protected : 对**同一包**内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类 （外部类）。
  -  public : 对**所有类**可见。使用对象：类、接口、变量、方法

|  修饰符   |  名称  | 同类 | 同包 | 子类 | 不同包 |
| :-------: | :----: | :--: | :--: | :--: | :----: |
|  public   |  公开  |  ✓   |  ✓   |  ✓   |   ✓    |
| protected | 受保护 |  ✓   |  ✓   |  ✓   |        |
|  default  |  默认  |  ✓   |  ✓   |      |        |
|  private  |  私有  |  ✓   |      |      |        |

---

## 11、&和&&的区别

- &运算符有两种用法：(1)按位与；(2)逻辑与。 
- &&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端 的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算，是因为如果&&左边的表 达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。

==**注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此**==

---

12、final 有什么用？

**用于修饰类、属性和方法；**

- 被final修饰的类不可以被继承 
- 被final修饰的方法不可以被重写 
- 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容， 引用指向的内容是可以改变的

---

## 13、this关键字的用法

- this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

- this的用法在java中大体可以分为3种：

  - 1.普通的直接引用，this相当于是指向当前对象本身。

  - 2.形参与成员名字重名，用this来区分：

  - 3.引用本类的构造函数

    ```java
    class Person{
    	private String name;
    	private int age;
    	
    	public Person() {
    	}
    	
    	public Person(String name) {
    	this.name = name;
    	}
    	
    	public Person(String name, int age) {
    	this(name);
    	this.age = age;
    	}
    }
    
    ```

---

## 14、super关键字的用法

- super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是**离自己最近**的一个父类
- super也有三种用法：
  - 普通的直接引用
    - 与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。
  - 子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分
  - 引用父类构造函数

注意：

- super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 
- this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。

------

## 15、 static

[java static 详解_春风化作秋雨的博客-CSDN博客_java static](https://blog.csdn.net/jiahao1186/article/details/121886704)

1、static范围

- **使用范围：**java `static`关键字可以用在变量、方法、代码块和嵌套类伤。
- **作用范围：**static`关键字属于类，而不是类的实例。`
- 静态(`static`)修饰如下：
  - 变量：称为类变量、静态变量
  - 方法：称为类方法、静态方法
  - 代码块：称为静态代码块
  - 嵌套类：称为静态内部类

2、静态变量

- 类的成员变量可以分为以下两种：
  - 静态变量（或称为类变量），指被 static 修饰的成员变量。
  - 实例变量，指没有被 static 修饰的成员变量。

- 静态变量与实例变量的区别如下：

  - 静态变量

    - 运行时，Java 虚拟机只为静态变量分配一次内存，加载类过程中完成静态变量的内存分配。
    - 在类的内部，可以在任何方法内直接访问静态变量。
    - 在其他类中，可以通过类名访问该类中的静态变量。

  - 实例变量

    - 每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。

    - 在类的内部，可以在非静态方法中直接访问实例变量。
    - 在本类的静态方法或其他类中则需要通过类的实例对象进行访问。

- 静态变量在类中的作用如下：

  - 静态变量可以被类的所有实例共享，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。

  - 如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。

3、静态方法

- ​	同成员变量，成员方法也可以分为以下两种：
  - 静态方法（或称为类方法），指被 static 修饰的成员方法。
  - 实例方法，指没有被 static 修饰的成员方法。
- 静态方法与实例方法的区别：
  - 静态方法，属于类，而不属于类的对象。
    - 1）它通过类直接被调用，无需创建类的对象。
    - 2）静态方法中，**不能使用 this 关键字**，**也不能直接访问所属类的实例变量和实例方法**；
    - 3）静态方法中，可以直接访问所属类的静态变量和静态方法。
    - 4）同this 关键字，super 关键字也与类的实例相关，**静态方法中不能使用 super 关键字**。
  - 实例方法，可直接访问所属类的静态变量、静态方法、实例变量和实例方法。

4、静态代码块

- 定义：静态代码块，是 Java 类中的 static{ } 修饰的代码。

- 作用：用于类初始化时，为类的静态变量赋初始值，提升程序性能。
- 静态代码块的特点如下：
  - 静态代码块，有点类似于一个方法，但不可以存在于任何方法体内。
  - 静态代码块，可以置于类中的任何地方，类中可以有多个静态初始化块。 
  - Java 虚拟机在加载类时执行，将只需要进行一次初始化的操作放在 static 代码块。
  - 类中含多个静态代码块，Java虚拟机将按它们在类中出现的顺序依次执行，且都执行一次。
  - 同静态代码块与静态，不能直接访问类的实例变量和实例方法，需通过类的对象访问。

5、静态类

 java中一个类要被声明为static的，只有一种情况，就是静态内部类（内嵌类）。如在外部类声明为static的，程序会编译都不会通过。

- 静态内部类，跟静态方法一样，只能访问静态成员变量和方法，不能访问非静态方法和属性。

- 普通内部类，可以访问任意外部类的成员变量和方法。

- 静态内部类，可以声明普通成员变量和方法，而普通内部类不能声明static成员变量和方法。

- 静态内部类，可以单独初始化。

==**适用场景：**==**当外部类需要使用内部类，而内部类无需外部类资源**，并且内部类可以单独创建时，考虑采用静态内部类的设计，在知道如何初始化静态内部类。



**==注意==**

1、静态只能访问静态。 

2、非静态既可以访问非静态的，也可以访问静态的。

---

## 16、break ,continue ,return 的区别及作用

- break 跳出总上一层循环，不再执行循环(结束当前的循环体) 
- continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件) 
- return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)

---

## 17、面向对象三大特征

面向对象的三大特征：封装、继承、多态。

- **封装**其实是对外隐藏复杂细节，提供简单易用的接口,便于外界调用，从而提高系统的可扩展性、可维护性。在Java中这种隐藏或公开是通过权限修饰符来实现的。

  ![封装](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302111103155.png)

- 继承--***extends*** 

  - 就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。简单来说，继承是把多个类中相同的内容给提取出来定义到一个类中，这个类就叫做父类，又称超类或基类，而多个类就是子类。
  - **注意**
    - **Java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类，但是一个类可以被多个类继承（一个子类只能有一个直接父类，一个父类可以有多个子类）**
    - **private修饰的属性和方法都是无法被子类继承的。**
    - **protected修饰的方法，就是用来给子类继承！！！**

  ![image-20220412223402273](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302111106199.png)

- 多态

  在继承基础上，才有多态

  - **概念**：父类引用指向子类实例。	

  ```java
  List list = new List();			// 创建List对象
  List list = new ArrayList();		// 多态
  ```

  - **多态的实现的必要条件:**
    - 存在继承关系
    - 存在方法重写
    - 父类引用指向子类对象

---

## 18、抽象类和接口的对比

- 抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。 
- 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规 范。

- 相同点
  - 接口和抽象类都不能实例化 
  - 都位于继承的顶端，用于被其他实现或继承 
  - 都包含抽象方法，其子类都必须覆写这些抽象方法

- 不同点

  |     参 数      |                            抽象类                            |                             接口                             |
  | :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |     声 明      |                 抽象类使用abstract关键字声明                 |                 接口使用interface关键字声明                  |
  |     实 现      | 子类使用extends关键字来继承抽象类。如果子类 不是抽象类的话，它需要提供抽象类中所有声明 的方法的实现 | 子类使用implements关键字来实现 接口。它需要提供接口中所有声明的 方法的实现 |
  |    构 造 器    |                      抽象类可以有构造器                      |                       接口不能有构造器                       |
  | 访 问 修 饰 符 |               抽象类中的方法可以是任意访问修饰               | 接口方法默认修饰符是public。并且 不允许定义为 private 或者 protected |
  |    多 继 承    |                 一个类最多只能继承一个抽象类                 |                    一个类可以实现多个接口                    |
  |  字 段 声 明   |                 抽象类的字段声明可以是任意的                 |            接口的字段默认都是 static 和 final 的             |

---

## 19、抽象类和普通类的区别

- 抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public。
- 抽象类不能用来创建对象；
- 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。

---

## 20、抽象类能使用 final 修饰吗？

不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生 矛盾，所以 final 不能修饰抽象类

---

## 21、在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？

帮助子类做初始化工作。

---

## 22、构造方法有哪些特性？

- 名字与类名相同； 
- 没有返回值，但不能用void声明构造函数；
-  生成类的对象时自动执行，无需调用。

---

## 23、内部类的优点

- 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！ 
- 内部类不为同一包的其他类所见，具有很好的封装性；
- 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。
- 匿名内部类可以很方便的定义回调。

---

## 24、构造器（constructor）是否可被重写（override）

构造器不能被继承，因此不能被重写，但可以被重载。

---

## 25、重载（Overload）和重写（Override）的区别

- 方法的重载和重写都是实现多态的方式，区别在于前者实现的是**编译时**的多态性，而后者实现的是运行时的多态性。
- 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分
- 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于 父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中 就不是重写。

| 名称           | 发生范围 | 方法名   | 形参列表                         | 返回类型                                             | 修饰符                               |
| -------------- | -------- | -------- | -------------------------------- | ---------------------------------------------------- | ------------------------------------ |
| 重载(overload) | 本类     | 必须一样 | `类型、个数、顺序`至少有一个不同 | 无要求                                               | 无要求                               |
| 重写(override) | 父子类   | 必须一样 | 相同                             | 子类重写的方法，`返回类型和父类一样或者是父类的子类` | 子类方法`不能缩小父类方法的访问范围` |

---

## 26、**==和equals方法的区别**

**==**

- **基本类型**：比较的是==值==是否相同； **引用类型**：比较的是==引用==是否相同；

**equals**

equals用来比较的是两个==对象的内容==是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。

**注意**

所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针

---

## 27、**hasCode()与equals()之间的关系**

[【每天一个技术点】hashCode()到底有什么用，为啥一定要和equals()重写_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Y44y1P7d5/?vd_source=cec214555361b7c4965a052921286a73)

> hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数。

hasCode()是native方法, 若果没有重写的, 会将内存地址转换为int数值进行返回;

hasCode()获取到的int值就是哈希码, 也成为散列码, 作用是确定该对象在哈希表中的索引位置。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

在Java的一些集合类的实现中，在比较两个对象是否相等时，会先调用对象的hashCode()方法得到hashCode进行比较，如果nashCode不相同，就可以直接认为这两个对象不相同，如果hashCodet相同，那么就会进一步调用equals()方法进行比较。而equals()方法，就是用来最终确定两个对象是不是相等的，通常equals()方法的实现会比较重，逻辑比较多，而hashCode()主要就是得到一个哈希值，实际上就一个数字，相对而言比较轻，所以在比较两个对象时，通常都会先根据hashCode想比较一下。

总结:

- 如果两个对象相等，则hashcode一定也是相同的

- 两个对象相等,对两个对象分别调用equals方法都返回true

- 两个对象有相同的hashcode值，它们也不一定是相等的

- 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖

- hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

  (因为对象存放的地址不一样)

### **哈希冲突**

![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154738.png)

**原因**

被哈希算法计算的数据是无限的,而计算后的结果的范围是有限的,所以总会存在不同的数据经过哈希计算之后得到的值是一样的;

**解决方法**

#### **1、开放定址法, 也称线性探测法**

![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154739.png)

- **举例**

  是当我们去教室上课，发现该位置已经存在人了，所以我们应该寻找新的位子坐下，这就是开放定址法的思路

- 当我们的所需要存放值的位置被占了，我们就往后面一直加1并对m取模直到存在一个空余的地址供我们存放值，取模是为了保证找到的位置在0~m-1的有效空间之中。

- 公式：h(x)=(Hash(x)+i)mod (Hashtable.length);（i会逐渐递增加1）

- java中ThreadLocal使用线性探测发解决哈希冲突

#### **2、链式寻址法**

![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154740.png)

- JDK1.8版本中HashMap是通过链式寻址法+红黑树方式解决冲突问题

  [(147条消息) HashMap底层实现原理概述_fedorafrog的博客-CSDN博客_hashmap底层实现原理](https://blog.csdn.net/fedorafrog/article/details/115478407)

- 每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.

#### **3、再哈希法:**

- 有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数
  计算地址,直到无冲突
- 该方式会增加运算时间, 会影响性能

#### **4、建立公共溢出区**

在创建哈希表的同时，再额外创建一个公共溢出区，专门用来存放发生哈希冲突的元素。凡是存在冲突的元素都放在溢出表中, 查找时，先从哈希表查，查不到再去公共溢出区查。

------

## 28、 对象的相等与指向他们的引用相等，两者有什么不同？

- 对象的相等 比的是内存中存放的内容是否相等
- 引用相等 比较的是他们指向的内存地址是否相等。

---

## 29、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并 可返回变化后的结果，那么这里到底是值传递还是引用传递

是值传递。

Java 语言的方法调用只支持参数的值传递。

当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的

---

## 30、值传递和引用传递有什么区别

- 值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递 后就互不相关了。
- 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是 变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用 （也就是同一个内存空间）。

---

## 31、 java 中 IO 流分为几种?

- 按照流的流向分，可以分为输入流和输出流； 
- 按照操作单元划分，可以划分为字节流和字符流； 
- 按照流的角色划分为节点流和处理流。

Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。

- InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 

- OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。

  - 字节输入流

    ![在这里插入图片描述](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302111443912.png)

  - 字节输出流

    ![在这里插入图片描述](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302111443704.png)

  - 字符输入流

    ![在这里插入图片描述](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302111442043.png)

  - 字符输出流

    ![在这里插入图片描述](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202302111442394.png)

---

## 32、 Files的常用方法都有哪些？

- Files. exists()：检测文件路径是否存在。 
- Files. createFile()：创建文件。 
- Files. createDirectory()：创建文件夹。 
- Files. delete()：删除一个文件或目录。 
- Files. copy()：复制文件。 
- Files. move()：移动文件。 
- Files. size()：查看文件个数。 
- Files. read()：读取文件。 
- Files. write()：写入文件。

---

### 33、反射

- 什么是反射机制？
  - JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
- 反射机制优缺点
  - 优点： 运行期类型的判断，动态加载类，提高代码灵活度。 
  - 缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。

- Java获取反射的三种方法

  - 通过new对象实现反射机制 

    ```java
    Student stu = new Student();
    Class classobj1 = stu.getClass();
    System.out.println(classobj1.getName());
    ```

  - 通过路径实现反射机制 

    ```java
    Class classobj2 = Class.forName("fanshe.Student");
    System.out.println(classobj2.getName());
    ```

  - 通过类名实现反射机制

    ```java
    Class classobj3 = Student.class;
    System.out.println(classobj3.getName());
    ```

---

## 33、字符型常量和字符串常量的区别

- 形式上: 
  - 字符常量是单引号引起的一个字符
  - 字符串常量是双引号引起的若干个字符 
- 含义上: 
  - 字符常量相当于一个整形值(ASCII值),可以参加表达式运算
  - **字符串常量代表一个地址值(该 字符串在内存中存放位置)** 
- 占内存大小 
  - 字符常量只占一个字节 
  - 字符串常量占若干个字节(至少一个字符结束标志)

----

## 34、什么是字符串常量池？

- 字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空 间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池 中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。

---

## 35、String不可变

1. 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。
2. String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。

[(147条消息) 【Java小知识】String为什么不可变？改变你对String不可变的认知_圆○的博客-CSDN博客_string不可变](https://blog.csdn.net/weixin_45342093/article/details/124895244)

- **通过反射可以修改所谓的不可变对象**

  ```xml
  // 创建字符串"Hello World"， 并赋给引用s
  String s = "Hello World";
  System.out.println("s = " + s); // Hello World
  
  // 获取String类中的value字段
  Field valueFieldOfString = String.class.getDeclaredField("value");
  
  // 改变value属性的访问权限
  valueFieldOfString.setAccessible(true);
  
  // 获取s对象上的value属性的值
  char[] value = (char[]) valueFieldOfString.get(s);
  
  // 改变value所引用的数组中的第5个字符
  value[5] = '_';
  System.out.println("s = " + s); // Hello_World
  ```

  结果：s = Hello World s = Hello_World

  解析:

  用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。

- 在使用 HashMap 的时候，用 String 做 key 有什么好处？

  HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，
  所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。

- String创建对象

  [(147条消息) Java基础-String对象的创建和存储_flytalei的博客-CSDN博客_java创建string对象](https://blog.csdn.net/flytalei/article/details/124405927)

  [(147条消息) 关于String如何创建对象_364.99°的博客-CSDN博客_使用string类建立对象](

---

## 36、String str="i"与 String str=new String(“i”)一样吗？

不一样，因为内存的分配方式不一样。

- String str="i"的方式，java 虚拟机会将其分配到**常量池**中； 

-  String str=new String(“i”) 则会被分到**堆内存**中。

---

## **37、String,StringBuffer,StrungBuilder的区别**

- String是final修饰的，不可变，每次操作都会产生新的String对象
- StringBuffer和StringBuilder都是在原对象上操作
- StringBuffer是线程安全的，StringBuilder线程不安全的
- StringBuffer方法都是synchronized修饰的
- 性能：StringBuilder > StringBuffer > String
- 场景：经常需要改变字符串内容时使用**StringBuffer,StrungBuilder**
  优先使用StringBuilder，多线程使用共享变量时使用StringBuffer

---

## 38、数组有没有 length()方法？String 有没有 length()方法

- 数组没有 length()方法 ，有 length 的属性。

- String 有 length()方法。

---

## 39、 String 类的常用方法都有那些？

- indexOf()：返回指定字符的索引。 
- charAt()：返回指定索引处的字符。 
- replace()：字符串替换。 
- trim()：去除字符串两端空白。 
- split()：分割字符串，返回一个分割后的字符串数组。
- getBytes()：返回字符串的 byte 类型数组。 
- length()：返回字符串长度。 
- toLowerCase()：将字符串转成小写字母。 
- toUpperCase()：将字符串转成大写字符。 
- substring()：截取字符串。 
- equals()：字符串比较。

---

## 40、在使用 HashMap 的时候，用 String 做 key 有什么好处？

HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的， 所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更 快。