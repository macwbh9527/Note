# 基础面试题

### **JDK,JRE,JVM之间的区别**

- **JDK**(Java SE Development Kit), Java开发工具包，它提供了**编译**、**运行**Java程序所需的各种工具和资源，包括**Java编译器**、**Java运行时环境**，以及常用的**Java类库**等

- **JRE**(Java Runtime Environment), Java运行环境，用于**运行**Java的字节码文件。JRE中包括了JVM以及JVM工作所需要的类库，普通用户而只需要安装JRE来运行Java程序，而程序开发者必须安装JDK来编译、调试程序。

  > Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java
  > Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包

- **JVM**(ava Virtual Mechinal), Java虚拟机，是JRE的一部分，它是整个java实现跨平台的最核心的部分，负责运行字节码文件。

我们写Jva代码，用txt就可以写，但是写出来的)ava代码，想要运行，需要先编译成**字节码**，那就需要编译器，而JDK中就包含了编译器javac. 编译之后的字节码，想要运行，就需要一个可以执行字节码的程序，这个程序就是JVM(Java虚拟机），专门用来执行Java字节码的。

如果我们要开发Java程序，那就需要JDK, 因为要编译Java源文件。
如果我们只想运行已经编译好的Java字节码文件，也就是*.class文件，那么就只需要JRE。
JDK中包含了JRE,JRE中包含了JVM。

另外，JVM在执行Java字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令是有可能不一样的，所以就导致不同操作系统上的JVM是不一样的，所以我们在安装JDK时需要选择操作系统。
另外，JVM是用来执行Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运行，比如Apache Groovy,Scala and Kotlin等等。

------



### **hasCode()与equals()之间的关系**

[【每天一个技术点】hashCode()到底有什么用，为啥一定要和equals()重写_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Y44y1P7d5/?vd_source=cec214555361b7c4965a052921286a73)

> hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数。

hasCode()是native方法, 若果没有重写的, 会将内存地址转换为int数值进行返回;

hasCode()获取到的int值就是哈希码, 也成为散列码, 作用是确定该对象在哈希表中的索引位置。

散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）

在Java的一些集合类的实现中，在比较两个对象是否相等时，会先调用对象的hashCode()方法得到hashCode进行比较，如果nashCode不相同，就可以直接认为这两个对象不相同，如果hashCodet相同，那么就会进一步调用equals()方法进行比较。而equals()方法，就是用来最终确定两个对象是不是相等的，通常equals()方法的实现会比较重，逻辑比较多，而hashCode()主要就是得到一个哈希值，实际上就一个数字，相对而言比较轻，所以在比较两个对象时，通常都会先根据hashCode想比较一下。

总结:

- 如果两个对象相等，则hashcode一定也是相同的

- 两个对象相等,对两个对象分别调用equals方法都返回true

- 两个对象有相同的hashcode值，它们也不一定是相等的

- 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖

- hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

  (因为对象存放的地址不一样)

  #### **哈希冲突**

  ![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154738.png)

  **原因**

  被哈希算法计算的数据是无限的,而计算后的结果的范围是有限的,所以总会存在不同的数据经过哈希计算之后得到的值是一样的;

  **解决方法**

  **1、开放定址法, 也称线性探测法**

  ![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154739.png)

  - **举例**

    是当我们去教室上课，发现该位置已经存在人了，所以我们应该寻找新的位子坐下，这就是开放定址法的思路

  - 当我们的所需要存放值的位置被占了，我们就往后面一直加1并对m取模直到存在一个空余的地址供我们存放值，取模是为了保证找到的位置在0~m-1的有效空间之中。

  - 公式：h(x)=(Hash(x)+i)mod (Hashtable.length);（i会逐渐递增加1）

  - java中ThreadLocal使用线性探测发解决哈希冲突

  **2、链式寻址法**

  ![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154740.png)

  - JDK1.8版本中HashMap是通过链式寻址法+红黑树方式解决冲突问题

    [(147条消息) HashMap底层实现原理概述_fedorafrog的博客-CSDN博客_hashmap底层实现原理](https://blog.csdn.net/fedorafrog/article/details/115478407)

  - 每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.

  **3、再哈希法:**

  - 有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数
    计算地址,直到无冲突
  - 该方式会增加运算时间, 会影响性能

  **4、建立公共溢出区**

  在创建哈希表的同时，再额外创建一个公共溢出区，专门用来存放发生哈希冲突的元素。凡是存在冲突的元素都放在溢出表中, 查找时，先从哈希表查，查不到再去公共溢出区查。

------



### **String,StringBuffer,StrungBuilder的区别**

- String是final修饰的，不可变，每次操作都会产生新的String对象
- StringBuffer和StringBuilder都是在原对象上操作
- StringBuffer是线程安全的，StringBuilder线程不安全的
- StringBuffer方法都是synchronized修饰的
- 性能：StringBuilder > StringBuffer > String
- 场景：经常需要改变字符串内容时使用**StringBuffer,StrungBuilder**
  优先使用StringBuilder，多线程使用共享变量时使用StringBuffer

#### String不可变

1. 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。
2. String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。

[(147条消息) 【Java小知识】String为什么不可变？改变你对String不可变的认知_圆○的博客-CSDN博客_string不可变](https://blog.csdn.net/weixin_45342093/article/details/124895244)

- **通过反射可以修改所谓的不可变对象**

  ```xml
  // 创建字符串"Hello World"， 并赋给引用s
  String s = "Hello World";
  System.out.println("s = " + s); // Hello World
  
  // 获取String类中的value字段
  Field valueFieldOfString = String.class.getDeclaredField("value");
  
  // 改变value属性的访问权限
  valueFieldOfString.setAccessible(true);
  
  // 获取s对象上的value属性的值
  char[] value = (char[]) valueFieldOfString.get(s);
  
  // 改变value所引用的数组中的第5个字符
  value[5] = '_';
  System.out.println("s = " + s); // Hello_World
  ```

  结果：s = Hello World s = Hello_World

  解析:

  用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。

- 在使用 HashMap 的时候，用 String 做 key 有什么好处？

  HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，
  所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。

- String创建对象

  [(147条消息) Java基础-String对象的创建和存储_flytalei的博客-CSDN博客_java创建string对象](https://blog.csdn.net/flytalei/article/details/124405927)

  [(147条消息) 关于String如何创建对象_364.99°的博客-CSDN博客_使用string类建立对象](https://blog.csdn.net/m0_54355172/article/details/124413450)

  

### **==和equals方法的区别**

**==**

- **基本类型**：比较的是值是否相同； **引用类型**：比较的是引用是否相同；

**equals**

equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。

**注意**

所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针

------



### **泛型中extends和super的区别**

对泛型的范围进行限制

<? extends T> 表示包括T在内的任何T的子类

<? super T> 表示包括T在内的任何T的父类

------



### 重写和重载的区别

| 定义不同 | 重载是定义相同的方法名、参数不同 | 重写是子类重写父类的方法                           |
| -------- | -------------------------------- | -------------------------------------------------- |
| 范围不同 | 重载是在一个类中                 | 重写是子类与父类之间的                             |
| 多态不同 | 重载是编译时的多态性             | 重写是运行时的多态性                               |
| 参数不同 | 重载的参数个数、参数类型         | 重写父类子方法参数必须相同                         |
| 修饰不同 | 重载对修饰范围没有要求           | 重写要求重写方法的修饰范围大于被重写方法的修饰范围 |

------



### List、Map、Set 的区别与联系

![集合的类型](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151453813.png)

#### List

- List 接口继承了 **Collection** 接口以定义一个 允许**有重复项** 的 有序 集合。
- **List 接口有三个实现类：**
  - **`ArrayList`**：底层数据结构是**数组**，关注的是索引，允许对元素进行快速随机访问（==查询快==），但是插入和删除元素会伴随后面数据的移动（==增删慢==）；效率高，线程不安全。
  - **`LinkedList`**：底层数据结构是**链表**，内存非连续，==增删快==，==查找慢==，效率高，线程不安全。
  - **`Vector`**：底层数据结构是**数组**，==增删慢==，==查找慢==，效率低，==线程安全==。
- **ArrayList和LinkedList的查询和插入逻辑：**
  - ArrayList：查询数据时，直接找到对应索引的值。插入数据时，若指定位置，则需要将该位置后所有元素向后移动，删除同理。
  - LinkedList：查询数据时，若索引值小于索引数据量的1/2，则从头开始查找，若索引值大于索引数据量的1/2，则从尾开始查找。插入数据时，需要先找到对应位置，所以和ArrayList相比不一定谁快谁慢。

#### Set

- Set 接口继承 Collection 接口，是 无序 的，且 **不允许存在重复项**。
- **Set 接口有三个实现类：**
  - **`HashSet`**：底层数据结构是**哈希表**，无序且**不允许有重复值**，**增删快**；**依赖方法 hashCode() 和 equals()。**
  - **`LinkedHashSet`**：HashSet 的子类，**继承于 HashSet**，同时又基于 **LinkedHashMap** 来进行实现，底层数据结构是**链表和哈希表**，使用的是 **LinkedHashMap**，由链表保证元素**有序**，哈希表保证**元素唯一**。
  - **`TreeSet`**：底层数据结构是**红黑树**，以升序对对象进行排序，TreeSet 类使用了一个 TreeMap。

#### Map

- Map 接口不是 Collection 接口的继承，而是从自己的用于维护键值对关联的接口层次结构入手，按定义，该接口描述了 ==从不重复的键到可重复的值== 的映射。

- **Map 接口有四个实现类：**

  - **`HashMap`**：底层数据结构是**哈希表**，**支持 null 值和 null 键**，效率高，线程不安全。
  - **`LinkedHashMap`**：HashMap 子类，底层数据结构是**链表和哈希表**，由链表保证**元素有序**，哈希表保证**元素唯一**。保存了记录的插入顺序。
  - **`TreeMap`**：底层数据结构是**红黑树**，能够把它保存的记录根据键排序，默认是键值的升序排序。

  - **`HashTable`**：底层数据结构是**哈希表**，**不支持 null 值和 null 键**，效率低，线程安全。

- #### **HashMap 和 HashTable 区别**

  - **HashMap** 是线程不安全的，HashMap 是 Map 的一个子接口，通过键的映射得到值，**不允许键重复**，**允许空键和空值**，由于非线程安全，HashMap 的效率要较 HashTable 的效率高一些；
  - **HashTable** 是线程安全的集合，**不允许空键或空值**；HashTable 被多个线程访问时不需要自己为它的方法实现同步，而 HashMap 在被多个线程访问的时候需要自己为它的方法实现同步。

#### ==List、Set 和 Map 的区别==

- `List` 和 `Set` 都继承自 collection 接口，`Map` 则不是。

- `List` 集合中对象按索引位置排序，可以有重复对象，允许按照对象在集合中的索引位置检索对象，例如可以通过 `list.get(i)` 方法来获取集合中的元素；
- `Map` 中的每一个元素包含一个键和一个值，成对出现，键对象不可以重复，值对象可以重复
- `Set` 集合中的对象不按照特定的方式排序，并且没有重复对象，但它能对集合中的对象按照特定的方式排序，例如 TreeSet 类。

------



### **CopyOnWriteArrayList的底层原理是怎样的**

- 首先CopyOnWriteArrayList内部也是用过数组来实现的，在向CopyOnWriteArrayListi添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行
- 写操作会加锁，防止出现井发写入丢失数据的问题

- 写操作结束之后会把原数组指向新数组
- CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能,  因此适合读多写少的应用场景，但是CopyOnWriteArrayList会比较占内存，同时可能读到的数据不是实时最新的数据，所以==不适合实时性要求很高的场景==

[CopyOnWriteArrayList的底层原理是怎样的](https://blog.csdn.net/rod0320/article/details/123051365)

------



### **说一下HashMap的Put方法**

- **大体流程**

  - 根据key通过哈希算法与运算得出数组下标；

  - 如果数组下标位置元素为空，则将key和value封装成为Entry对象（JDK1.7中是Entry对象，JDK1.8中是Node对象）并放入该位置；


  - 如果数组下标位置元素不为空，则要分情况讨论；

    - 如果是JDK1.7，则先判断是否扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用**头插法**添加到当前位置的链表中；

    - 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node；

      ①：如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中，在这个过程中会判断红黑树中是否存在当前的key，如果存在则是更新value；

      ②：如果是链表节点Node，则将key和value封装成为一个链表Node并通过尾插法插入到链表的最后位置去。由于是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在则更新value。当遍历完链表后，将新链表Node插入到链表中，插入到链表中后，会判断当前链表节点个数，如果是大于8，那么则会将该链表转成红黑树；

      ③：在将key和value封装为Node插入到链表或红黑树中后，再判断是否需要扩容，如果需要扩容就扩容，不需要就结束put方法。   

- **图解**

  ![img](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151543054.png)

- **源码分析**

  ```java
  //put方法，会先调用一个hash()方法，得到当前key的一个hash值，
  //用于确定当前key应该存放在数组的哪个下标位置
  //这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲
   public V put(K key, V value) {
   
          //返回调用putVal方法
          return putVal(hash(key), key, value, false, true);
      }
  ```

  ```Java
  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                     boolean evict) {
          Node<K,V>[] tab; Node<K,V> p; int n, i;
          //首先会获取tab容器大小，如果为空则会赋值初始化大小
          //DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
          if ((tab = table) == null || (n = tab.length) == 0)
              n = (tab = resize()).length;
          if ((p = tab[i = (n - 1) & hash]) == null)
          	//判断，如果当前位置的元素为空，则直接将key，value封装成node添加到tab中
              tab[i] = newNode(hash, key, value, null);
          else {
          	//当前元素不为空，则分情况判断
              Node<K,V> e; K k;
              if (p.hash == hash &&
                  ((k = p.key) == key || (key != null && key.equals(k))))
                  /*
                  	首先根据hash值和key值判断是否存在相同的key，如果存在， 则直接替换掉原来的value
                  */
                  e = p;
              else if (p instanceof TreeNode)
              	//如果不存在，判断当前Node节点是否为红黑树树节点，如果是，
              	//则将key和value封装成红黑树节点并添加到红黑树中
                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
              else {
              	/** 如果是链表节点，则需要循环当前链表
              		并且在循环链表的时候，需要对当前key进行判断，是否存在相同的key，
              		如果存在，则直接替换掉原来的value
              		如果不存在，则循环到最后一个位置，然后将key，value封装成链表Node节点
              		并添加到链表中（newNode），同时，获取当前链表节点数，
              		如果>=TREEIFY_THRESHOLD =8,则直接调用treeifyBin可能将链表转成红黑树
              		（treeifyBin中会判断当前容器n.length的大小，
              		如果 < MIN_TREEIFY_CAPACITY = 64,则不会直接转成红黑树，而是调用
              		resize()进行扩容操作，如果n.length >= 64 ，则将链表node节点替换成
              		treeNode,转成红黑树）
              	*/
                  for (int binCount = 0; ; ++binCount) {
                      if ((e = p.next) == null) {
                          p.next = newNode(hash, key, value, null);
                          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                              treeifyBin(tab, hash);
                          break;
                      }
                      if (e.hash == hash &&
                          ((k = e.key) == key || (key != null && key.equals(k))))
                          break;
                      p = e;
                  }
              }
              if (e != null) { // existing mapping for key
                  V oldValue = e.value;
                  if (!onlyIfAbsent || oldValue == null)
                      e.value = value;
                  afterNodeAccess(e);
                  return oldValue;
              }
          }
          ++modCount;
          /*
          	threshold默认为DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
  			最后无论是链表，还是红黑树，都需要对其进行扩容判断，如果需要扩容，
  			一般扩容大小为原来的2倍newThr = oldThr << 1; // double threshold
  			则进行扩容，否则，结束put方法
  		*/
          if (++size > threshold)
              resize();
          afterNodeInsertion(evict);
          return null;
      }
  
  ```

------



### **HashMap的扩容机制原理**

- HashMap扩容的时机取决于扩容阈值threshold，阈值的计算规则为threshold = capicaty *loadFactor，初始容量capicaty 默认16，负载因子为0.75， 当HashMap的size大于或等于 threshold则HashMap会进行扩容处理。
- **流程**
  - 先生成新数组
  - 遍历老数组中的每个位置上的链表或红黑树
  - 如果是链表，则直接将链表中的每个元素重计算下标，并添加到新数组中去
  - 如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置
    - 统计每个下标位置的元素个数
    - 如果该位置下的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置
    - 如果该位置下的元素个数没有超过8，那么则生成一个链表，并将链表的头节点添加到新数组的对应位置
  - 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

------



### **谈谈ConcurrentHashMap的扩容机制**

[ConcurrentHashMap的扩容](https://blog.csdn.net/pc_fly/article/details/125108562)

- **流程**
  - 1.8版本的ConcurrentHashMap不再基于Segment分段实现
  - 当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容
  - 如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过同值，超过了则进行扩容
  - ConcurrentHashMap是支持多个线程同时扩容的
  - 扩容之前也先生成一个新的数组
  - 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作

------

### 深拷贝和浅拷贝的区别