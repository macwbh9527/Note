# 基础面试题

- **JDK,JRE,JVM之间的区别**
    - JDK(Java SE Development Kit), Java开发工具包，它提供了**编译**、**运行**Java程序所需的各种工具和资源，包括**Java编译器**、**Java运行时环境**，以及常用的**Java类库**等
    - JRE(Java Runtime Environment), Java运行环境，用于**运行**Java的字节码文件。JRE中包括了JVM以及JVM工作所需要的类库，普通用户而只需要安装JRE来运行Java程序，而程序开发者必须安装JDK来编译、调试程序。
      
        > Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java
        Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包
        > 
    - JVM(ava Virtual Mechinal), Java虚拟机，是JRE的一部分，它是整个java实现跨平台的最核心的部分，负责运行字节码文件。
    
    我们写Jva代码，用txt就可以写，但是写出来的)ava代码，想要运行，需要先编译成**字节码**，那就需要编译器，而JDK中就包含了编译器javac. 编译之后的字节码，想要运行，就需要一个可以执行字节码的程序，这个程序就是JVM(Java虚拟机），专门用来执行Java字节码的。
    
    如果我们要开发Java程序，那就需要JDK, 因为要编译Java源文件。
    如果我们只想运行已经编译好的Java字节码文件，也就是*.class文件，那么就只需要JRE。
    JDK中包含了JRE,JRE中包含了JVM。
    
    另外，JVM在执行Java字节码时，需要把字节码解释为机器指令，而不同操作系统的机器指令是有可能不一样的，所以就导致不同操作系统上的JVM是不一样的，所以我们在安装JDK时需要选择操作系统。
    另外，JVM是用来执行Java字节码的，所以凡是某个代码编译之后是Java字节码，那就都能在JVM上运行，比如Apache Groovy,Scala and Kotlin等等。
    
- **hasCode()与equals()之间的关系**
  
    [【每天一个技术点】hashCode()到底有什么用，为啥一定要和equals()重写_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Y44y1P7d5/?vd_source=cec214555361b7c4965a052921286a73)
    
    > hashCode() 定义在JDK的Object.java中，Java中的任何类都包含有hashCode() 函数。
    > 
    
    hasCode()是native方法, 若果没有重写的, 会将内存地址转换为int数值进行返回;
    
    hasCode()获取到的int值就是哈希码, 也成为散列码, 作用是确定该对象在哈希表中的索引位置。
    
    散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）
    
    在Java的一些集合类的实现中，在比较两个对象是否相等时，会先调用对象的hashCode()方法得到hashCode进行比较，如果nashCode不相同，就可以直接认为这两个对象不相同，如果hashCodet相同，那么就会进一步调用equals()方法进行比较。而equals()方法，就是用来最终确定两个对象是不是相等的，通常equals()方法的实现会比较重，逻辑比较多，而hashCode()主要就是得到一个哈希值，实际上就一个数字，相对而言比较轻，所以在比较两个对象时，通常都会先根据hashCode想比较一下。
    
    总结:
    
    - 如果两个对象相等，则hashcode一定也是相同的
    - 两个对象相等,对两个对象分别调用equals方法都返回true
    - 两个对象有相同的hashcode值，它们也不一定是相等的
    - 因此，equals方法被覆盖过，则hashCode方法也必须被覆盖
    - hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）
      
        (因为对象存放的地址不一样)
        
    - 哈希冲突
      
        ![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154738.png)
        
        **原因**
        
        被哈希算法计算的数据是无限的,而计算后的结果的范围是有限的,所以总会存在不同的数据经过哈希计算之后得到的值是一样的;
        
        **解决方法**
        
        - 开放定址法, 也称线性探测法
          
            ![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154739.png)
            
            - **举例**
              
                是当我们去教室上课，发现该位置已经存在人了，所以我们应该寻找新的位子坐下，这就是开放定址法的思路
                
            - 当我们的所需要存放值的位置被占了，我们就往后面一直加1并对m取模直到存在一个空余的地址供我们存放值，取模是为了保证找到的位置在0~m-1的有效空间之中。
            - 公式：h(x)=(Hash(x)+i)mod (Hashtable.length);（i会逐渐递增加1）
            - java中ThreadLocal使用线性探测发解决哈希冲突
        - 链式寻址法
          
            ![Untitled](https://raw.githubusercontent.com/macwbh9527/Note/main/image/202301151154740.png)
            
            - JDK1.8版本中HashMap是通过链式寻址法+红黑树方式解决冲突问题
              
                [(147条消息) HashMap底层实现原理概述_fedorafrog的博客-CSDN博客_hashmap底层实现原理](https://blog.csdn.net/fedorafrog/article/details/115478407)
                
            - 每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.
        - 再哈希法:
            - 有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数
            计算地址,直到无冲突
            - 该方式会增加运算时间, 会影响性能
        - 建立公共溢出区
          
            在创建哈希表的同时，再额外创建一个公共溢出区，专门用来存放发生哈希冲突的元素。凡是存在冲突的元素都放在溢出表中, 查找时，先从哈希表查，查不到再去公共溢出区查。
            
    
- **String,StringBuffer,StrungBuilder的区别**
    - String是final修饰的，不可变，每次操作都会产生新的String对象
    - StringBuffer和StringBuilder都是在原对象上操作
    - StringBuffer是线程安全的，StringBuilder线程不安全的
    - StringBuffer方法都是synchronized修饰的
    - 性能：StringBuilder > StringBuffer > String
    - 场景：经常需要改变字符串内容时使用**StringBuffer,StrungBuilder**
    优先使用StringBuilder，多线程使用共享变量时使用StringBuffer
    - String不可变
        1. 保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。
        2. String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。
        
        [(147条消息) 【Java小知识】String为什么不可变？改变你对String不可变的认知_圆○的博客-CSDN博客_string不可变](https://blog.csdn.net/weixin_45342093/article/details/124895244)
        
        - **通过反射可以修改所谓的不可变对象**
          
            ```xml
            // 创建字符串"Hello World"， 并赋给引用s
            String s = "Hello World";
            System.out.println("s = " + s); // Hello World
            
            // 获取String类中的value字段
            Field valueFieldOfString = String.class.getDeclaredField("value");
            
            // 改变value属性的访问权限
            valueFieldOfString.setAccessible(true);
            
            // 获取s对象上的value属性的值
            char[] value = (char[]) valueFieldOfString.get(s);
            
            // 改变value所引用的数组中的第5个字符
            value[5] = '_';
            System.out.println("s = " + s); // Hello_World
            ```
            
            结果：s = Hello World s = Hello_World
            
            解析:
            
            用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。
            
        - 在使用 HashMap 的时候，用 String 做 key 有什么好处？
          
            HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，
            所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。
        
    - String创建对象
      
        [(147条消息) Java基础-String对象的创建和存储_flytalei的博客-CSDN博客_java创建string对象](https://blog.csdn.net/flytalei/article/details/124405927)
        
        [(147条消息) 关于String如何创建对象_364.99°的博客-CSDN博客_使用string类建立对象](https://blog.csdn.net/m0_54355172/article/details/124413450)
        
    
- **==和equals方法的区别**
  
    **==**
    
    - **基本类型**：比较的是值是否相同； **引用类型**：比较的是引用是否相同；
    
    **equals**
    
    equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。
    
    **注意**
    
    所有比较是否相等时，都是用equals 并且在对常量相比较时，把常量写在前面，因为使用object的equals object可能为null 则空指针
    
- **泛型中extends和super的区别**
  
    对泛型的范围进行限制
    
    <? extends T> 表示包括T在内的任何T的子类
    
    <? super T> 表示包括T在内的任何T的父类